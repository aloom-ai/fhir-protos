//    Copyright 2018 Google Inc.
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        https://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file proto/google/fhir/proto/profile_config.proto (package google.fhir.proto, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { FhirVersion } from "./annotations_pb.js";
import { ElementDefinition } from "./r4/core/datatypes_pb.js";
import { BindingStrengthCode_Value, PublicationStatusCode_Value, SlicingRulesCode_Value } from "./r4/core/codes_pb.js";

/**
 * @generated from enum google.fhir.proto.SizeRestriction
 */
export enum SizeRestriction {
  /**
   * Does not set a size restriction on the field.
   *
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   * Field should have zero values, i.e. omitted from the record.
   *
   * @generated from enum value: ABSENT = 1;
   */
  ABSENT = 1,

  /**
   * Field must have exactly one value.
   *
   * @generated from enum value: REQUIRED = 2;
   */
  REQUIRED = 2,

  /**
   * Field may have zero or one value.
   *
   * @generated from enum value: OPTIONAL = 3;
   */
  OPTIONAL = 3,

  /**
   * Repeated field that should have at least one value.
   *
   * @generated from enum value: AT_LEAST_ONE = 4;
   */
  AT_LEAST_ONE = 4,

  /**
   * Repeated field that may have zero or more values.
   *
   * @generated from enum value: REPEATED = 5;
   */
  REPEATED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(SizeRestriction)
proto3.util.setEnumType(SizeRestriction, "google.fhir.proto.SizeRestriction", [
  { no: 0, name: "UNSET" },
  { no: 1, name: "ABSENT" },
  { no: 2, name: "REQUIRED" },
  { no: 3, name: "OPTIONAL" },
  { no: 4, name: "AT_LEAST_ONE" },
  { no: 5, name: "REPEATED" },
]);

/**
 * Config containing all info needed to generate the core protos for a FHIR
 * version (e.g., R4, R5).
 * This should only contain info that is unique to proto generation (like proto
 * package) and therefore not contain information that can be found in the FHIR
 * definitions themselves.
 *
 * @generated from message google.fhir.proto.ProtogenConfig
 */
export class ProtogenConfig extends Message<ProtogenConfig> {
  /**
   * Package for the generated protos for the resources.
   *
   * @generated from field: string proto_package = 1;
   */
  protoPackage = "";

  /**
   * Java package for the generated protos for the resources.
   *
   * @generated from field: string java_proto_package = 2;
   */
  javaProtoPackage = "";

  /**
   * The package to reference for normative protos.  This can be the same as
   * proto_package for single-version mode.
   *
   * @generated from field: string normative_package = 3;
   */
  normativePackage = "";

  /**
   * Directory to place generated package.  This is needed for intra-package
   * imports.
   *
   * @generated from field: string source_directory = 4;
   */
  sourceDirectory = "";

  /**
   * Directory to use for normative resources.  This can be the same as
   * source_directory for single-version mode.
   *
   * @generated from field: string normative_directory = 5;
   */
  normativeDirectory = "";

  /**
   * The copyright date to be included in the license text, which
   * may simply be a year.
   *
   * @generated from field: string license_date = 6;
   */
  licenseDate = "";

  constructor(data?: PartialMessage<ProtogenConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ProtogenConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proto_package", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "java_proto_package", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "normative_package", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "source_directory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "normative_directory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "license_date", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProtogenConfig {
    return new ProtogenConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProtogenConfig {
    return new ProtogenConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProtogenConfig {
    return new ProtogenConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ProtogenConfig | PlainMessage<ProtogenConfig> | undefined, b: ProtogenConfig | PlainMessage<ProtogenConfig> | undefined): boolean {
    return proto3.util.equals(ProtogenConfig, a, b);
  }
}

/**
 * Metadata for generating FHIR packages
 *
 * @generated from message google.fhir.proto.PackageInfo
 */
export class PackageInfo extends Message<PackageInfo> {
  /**
   * FHIR version for the package (e.g., STU3, R4, R5, etc).
   *
   * @generated from field: google.fhir.proto.FhirVersion fhir_version = 1;
   */
  fhirVersion = FhirVersion.FHIR_VERSION_UNKNOWN;

  /**
   * Base url to use for all profiles defined here.
   * e.g., g.co/fhir/profiles
   *
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  /**
   * Package for the generated protos for the resources.
   *
   * @generated from field: string proto_package = 3;
   */
  protoPackage = "";

  /**
   * Java package for the generated protos for the resources.
   *
   * @generated from field: string java_proto_package = 4;
   */
  javaProtoPackage = "";

  /**
   * Defines whether to generate a local ContainedResource proto or reuse one.
   * If neither of these fields are set, use the core contained resource on
   * all generated files.
   *
   * @generated from oneof google.fhir.proto.PackageInfo.contained_resource
   */
  containedResource: {
    /**
     * Generates a local ContainedResource
     *
     * @generated from field: bool local_contained_resource = 6;
     */
    value: boolean;
    case: "localContainedResource";
  } | {
    /**
     * for the profiles being created.
     *
     * A fully-qualified
     *
     * @generated from field: string contained_resource_package = 7;
     */
    value: string;
    case: "containedResourcePackage";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: string publisher = 8;
   */
  publisher = "";

  /**
   * @generated from field: string telcom_url = 9;
   */
  telcomUrl = "";

  /**
   * @generated from field: google.fhir.proto.PackageInfo.License license = 10;
   */
  license = PackageInfo_License.NONE;

  /**
   * The copyright date to be included in the license text, which
   * may simply be a year. The generator will use the current year
   * if this is unset.
   *
   * @generated from field: string license_date = 11;
   */
  licenseDate = "";

  /**
   * If unset, defaults to TYPED_CONTAINED_RESOURCE for DSTU2 and STU3, and
   * ANY for later versions.
   *
   * @generated from field: google.fhir.proto.PackageInfo.ContainedResourceBehavior contained_resource_behavior = 12;
   */
  containedResourceBehavior = PackageInfo_ContainedResourceBehavior.DEFAULT;

  /**
   * If unset, defaults to no splitting
   *
   * @generated from field: google.fhir.proto.PackageInfo.FileSplittingBehavior file_splitting_behavior = 13;
   */
  fileSplittingBehavior = PackageInfo_FileSplittingBehavior.DEFAULT_SPLITTING_BEHAVIOR;

  /**
   * The package's version number.
   *
   * @generated from field: string version = 14;
   */
  version = "";

  constructor(data?: PartialMessage<PackageInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.PackageInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fhir_version", kind: "enum", T: proto3.getEnumType(FhirVersion) },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "proto_package", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "java_proto_package", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "local_contained_resource", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "contained_resource" },
    { no: 7, name: "contained_resource_package", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "contained_resource" },
    { no: 8, name: "publisher", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "telcom_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "license", kind: "enum", T: proto3.getEnumType(PackageInfo_License) },
    { no: 11, name: "license_date", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "contained_resource_behavior", kind: "enum", T: proto3.getEnumType(PackageInfo_ContainedResourceBehavior) },
    { no: 13, name: "file_splitting_behavior", kind: "enum", T: proto3.getEnumType(PackageInfo_FileSplittingBehavior) },
    { no: 14, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackageInfo {
    return new PackageInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackageInfo {
    return new PackageInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackageInfo {
    return new PackageInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PackageInfo | PlainMessage<PackageInfo> | undefined, b: PackageInfo | PlainMessage<PackageInfo> | undefined): boolean {
    return proto3.util.equals(PackageInfo, a, b);
  }
}

/**
 * The license to include in the generated profile, if any.
 *
 * @generated from enum google.fhir.proto.PackageInfo.License
 */
export enum PackageInfo_License {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: APACHE = 1;
   */
  APACHE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(PackageInfo_License)
proto3.util.setEnumType(PackageInfo_License, "google.fhir.proto.PackageInfo.License", [
  { no: 0, name: "NONE" },
  { no: 1, name: "APACHE" },
]);

/**
 * @generated from enum google.fhir.proto.PackageInfo.ContainedResourceBehavior
 */
export enum PackageInfo_ContainedResourceBehavior {
  /**
   * See field below for default behavior.
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * Uses protobuf.Any for contained resource fields.
   *
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * Use the corresponding resource protos
   *
   * @generated from enum value: TYPED_CONTAINED_RESOURCE = 2;
   */
  TYPED_CONTAINED_RESOURCE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PackageInfo_ContainedResourceBehavior)
proto3.util.setEnumType(PackageInfo_ContainedResourceBehavior, "google.fhir.proto.PackageInfo.ContainedResourceBehavior", [
  { no: 0, name: "DEFAULT" },
  { no: 1, name: "ANY" },
  { no: 2, name: "TYPED_CONTAINED_RESOURCE" },
]);

/**
 * How the output messages should be divided into files.
 *
 * @generated from enum google.fhir.proto.PackageInfo.FileSplittingBehavior
 */
export enum PackageInfo_FileSplittingBehavior {
  /**
   * Default is NO_SPLITTING
   *
   * @generated from enum value: DEFAULT_SPLITTING_BEHAVIOR = 0;
   */
  DEFAULT_SPLITTING_BEHAVIOR = 0,

  /**
   * All messages will be output into a single file,
   *
   * @generated from enum value: NO_SPLITTING = 1;
   */
  NO_SPLITTING = 1,

  /**
   * regardless of type
   *
   * All extensions will be put into a single file,
   *
   * @generated from enum value: SEPARATE_EXTENSIONS = 2;
   */
  SEPARATE_EXTENSIONS = 2,

  /**
   * and all other types will be put into a second
   * file
   *
   * Like SEPARATE_EXTENSIONS, all extensions will
   *
   * @generated from enum value: SPLIT_RESOURCES = 3;
   */
  SPLIT_RESOURCES = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PackageInfo_FileSplittingBehavior)
proto3.util.setEnumType(PackageInfo_FileSplittingBehavior, "google.fhir.proto.PackageInfo.FileSplittingBehavior", [
  { no: 0, name: "DEFAULT_SPLITTING_BEHAVIOR" },
  { no: 1, name: "NO_SPLITTING" },
  { no: 2, name: "SEPARATE_EXTENSIONS" },
  { no: 3, name: "SPLIT_RESOURCES" },
]);

/**
 * Config for definition of Profiles that are part of an Implementation
 * Guide to be generated
 *
 * @generated from message google.fhir.proto.Profiles
 */
export class Profiles extends Message<Profiles> {
  /**
   * @generated from field: repeated google.fhir.proto.Profile profile = 2;
   */
  profile: Profile[] = [];

  constructor(data?: PartialMessage<Profiles>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.Profiles";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "profile", kind: "message", T: Profile, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Profiles {
    return new Profiles().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Profiles {
    return new Profiles().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Profiles {
    return new Profiles().fromJsonString(jsonString, options);
  }

  static equals(a: Profiles | PlainMessage<Profiles> | undefined, b: Profiles | PlainMessage<Profiles> | undefined): boolean {
    return proto3.util.equals(Profiles, a, b);
  }
}

/**
 * Config for definition of Extensions  that are part of an Implementation
 * Guide to be generated
 *
 * @generated from message google.fhir.proto.Extensions
 */
export class Extensions extends Message<Extensions> {
  /**
   * @generated from field: repeated google.fhir.proto.SimpleExtension simple_extension = 2;
   */
  simpleExtension: SimpleExtension[] = [];

  /**
   * @generated from field: repeated google.fhir.proto.ComplexExtension complex_extension = 3;
   */
  complexExtension: ComplexExtension[] = [];

  constructor(data?: PartialMessage<Extensions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.Extensions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "simple_extension", kind: "message", T: SimpleExtension, repeated: true },
    { no: 3, name: "complex_extension", kind: "message", T: ComplexExtension, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Extensions {
    return new Extensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Extensions {
    return new Extensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Extensions {
    return new Extensions().fromJsonString(jsonString, options);
  }

  static equals(a: Extensions | PlainMessage<Extensions> | undefined, b: Extensions | PlainMessage<Extensions> | undefined): boolean {
    return proto3.util.equals(Extensions, a, b);
  }
}

/**
 * Config for definition of Terminologies (CodeSysems and ValueSets) that are
 * part of an Implementation Guide to be generated
 *
 * @generated from message google.fhir.proto.Terminologies
 */
export class Terminologies extends Message<Terminologies> {
  /**
   * @generated from field: repeated google.fhir.proto.CodeSystemConfig code_system = 1;
   */
  codeSystem: CodeSystemConfig[] = [];

  /**
   * @generated from field: repeated google.fhir.proto.ValueSetConfig value_set = 2;
   */
  valueSet: ValueSetConfig[] = [];

  constructor(data?: PartialMessage<Terminologies>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.Terminologies";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code_system", kind: "message", T: CodeSystemConfig, repeated: true },
    { no: 2, name: "value_set", kind: "message", T: ValueSetConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Terminologies {
    return new Terminologies().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Terminologies {
    return new Terminologies().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Terminologies {
    return new Terminologies().fromJsonString(jsonString, options);
  }

  static equals(a: Terminologies | PlainMessage<Terminologies> | undefined, b: Terminologies | PlainMessage<Terminologies> | undefined): boolean {
    return proto3.util.equals(Terminologies, a, b);
  }
}

/**
 * Defines a profile for a specific FHIR resource.
 *
 * @generated from message google.fhir.proto.Profile
 */
export class Profile extends Message<Profile> {
  /**
   * Description of the top-level element of the FHIR profile. For instance,
   * this would be "Patient" in a patient profile.
   *
   * @generated from field: google.fhir.proto.ElementData element_data = 1;
   */
  elementData?: ElementData;

  /**
   * Url of the Structure Definition being profiled
   * e.g., http://hl7.org/fhir/StructureDefinition/Patient
   *
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  /**
   * Element definitions to merge into the base definitions.
   * Each ElementDefinition added here will be merged on top of the base
   * definition for the element with the same ID, allowing adding new
   * restrictions or documentation to the field. This cannot add any new fields,
   * and it is invalid to supply an ElementDefinition whose id does not
   * correspond to an id in the base definition.
   *
   * @generated from field: repeated google.fhir.r4.core.ElementDefinition element_definition = 6;
   */
  elementDefinition: ElementDefinition[] = [];

  /**
   * Extensions to be inlined as fields
   *
   * @generated from field: repeated google.fhir.proto.ExtensionSlice extension_slice = 4;
   */
  extensionSlice: ExtensionSlice[] = [];

  /**
   * CodeableConcept field to slice by Coding system uri.
   *
   * @generated from field: repeated google.fhir.proto.CodeableConceptSlice codeable_concept_slice = 5;
   */
  codeableConceptSlice: CodeableConceptSlice[] = [];

  /**
   * Restrictions to existing fields (does not add new fields/slices)
   * DEPRECATED - use `element_definition` instead
   *
   * @generated from field: repeated google.fhir.proto.FieldRestriction restriction = 3;
   */
  restriction: FieldRestriction[] = [];

  constructor(data?: PartialMessage<Profile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.Profile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_data", kind: "message", T: ElementData },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "element_definition", kind: "message", T: ElementDefinition, repeated: true },
    { no: 4, name: "extension_slice", kind: "message", T: ExtensionSlice, repeated: true },
    { no: 5, name: "codeable_concept_slice", kind: "message", T: CodeableConceptSlice, repeated: true },
    { no: 3, name: "restriction", kind: "message", T: FieldRestriction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Profile {
    return new Profile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Profile {
    return new Profile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Profile {
    return new Profile().fromJsonString(jsonString, options);
  }

  static equals(a: Profile | PlainMessage<Profile> | undefined, b: Profile | PlainMessage<Profile> | undefined): boolean {
    return proto3.util.equals(Profile, a, b);
  }
}

/**
 * A restriction on a single field.
 *
 * @generated from message google.fhir.proto.FieldRestriction
 */
export class FieldRestriction extends Message<FieldRestriction> {
  /**
   * Id in the Structure Definition of the field to modify.
   * e.g., Patient.birthDate
   *
   * @generated from field: string field_id = 1;
   */
  fieldId = "";

  /**
   * Restriction on the size of the field.  Must be stricter than the
   * original - the new size must be a valid subset of the original.
   *
   * @generated from field: google.fhir.proto.SizeRestriction size_restriction = 2;
   */
  sizeRestriction = SizeRestriction.UNSET;

  /**
   * For reference fields, restricts what resources the reference
   * can point to. Must be a subset of the original.
   *
   * @generated from field: google.fhir.proto.ReferenceRestriction reference_restriction = 3;
   */
  referenceRestriction?: ReferenceRestriction;

  /**
   * For choice fields, restricts what types the choice can have.
   * Must be a subset of the original.
   *
   * @generated from field: google.fhir.proto.ChoiceTypeRestriction choice_type_restriction = 4;
   */
  choiceTypeRestriction?: ChoiceTypeRestriction;

  /**
   * @generated from field: repeated google.fhir.proto.FhirPathConstraint fhir_path_constraint = 5;
   */
  fhirPathConstraint: FhirPathConstraint[] = [];

  /**
   * For fields of type code, Coding, or CodeableConcept, binding to a ValueSet.
   * See: https://www.hl7.org/fhir/terminologies.html
   *
   * @generated from field: google.fhir.proto.ValueSetBinding value_set_binding = 6;
   */
  valueSetBinding?: ValueSetBinding;

  constructor(data?: PartialMessage<FieldRestriction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.FieldRestriction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_restriction", kind: "enum", T: proto3.getEnumType(SizeRestriction) },
    { no: 3, name: "reference_restriction", kind: "message", T: ReferenceRestriction },
    { no: 4, name: "choice_type_restriction", kind: "message", T: ChoiceTypeRestriction },
    { no: 5, name: "fhir_path_constraint", kind: "message", T: FhirPathConstraint, repeated: true },
    { no: 6, name: "value_set_binding", kind: "message", T: ValueSetBinding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldRestriction {
    return new FieldRestriction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldRestriction {
    return new FieldRestriction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldRestriction {
    return new FieldRestriction().fromJsonString(jsonString, options);
  }

  static equals(a: FieldRestriction | PlainMessage<FieldRestriction> | undefined, b: FieldRestriction | PlainMessage<FieldRestriction> | undefined): boolean {
    return proto3.util.equals(FieldRestriction, a, b);
  }
}

/**
 * For Reference types, additional restrictions to apply
 *
 * @generated from message google.fhir.proto.ReferenceRestriction
 */
export class ReferenceRestriction extends Message<ReferenceRestriction> {
  /**
   * Allowed types to refer to.
   * Must use unprofiled FHIR resource type name,
   * e.g., Patient, Observation, Medication
   *
   * @generated from field: repeated string allowed = 1;
   */
  allowed: string[] = [];

  constructor(data?: PartialMessage<ReferenceRestriction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ReferenceRestriction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReferenceRestriction {
    return new ReferenceRestriction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReferenceRestriction {
    return new ReferenceRestriction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReferenceRestriction {
    return new ReferenceRestriction().fromJsonString(jsonString, options);
  }

  static equals(a: ReferenceRestriction | PlainMessage<ReferenceRestriction> | undefined, b: ReferenceRestriction | PlainMessage<ReferenceRestriction> | undefined): boolean {
    return proto3.util.equals(ReferenceRestriction, a, b);
  }
}

/**
 * Which types are allowed for Choice types. These typically come from
 * the types at https://www.hl7.org/fhir/valueset-defined-types.html
 * but custom types ccan be used as well.
 *
 * @generated from message google.fhir.proto.ChoiceTypeRestriction
 */
export class ChoiceTypeRestriction extends Message<ChoiceTypeRestriction> {
  /**
   * @generated from field: repeated string allowed = 1;
   */
  allowed: string[] = [];

  constructor(data?: PartialMessage<ChoiceTypeRestriction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ChoiceTypeRestriction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChoiceTypeRestriction {
    return new ChoiceTypeRestriction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChoiceTypeRestriction {
    return new ChoiceTypeRestriction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChoiceTypeRestriction {
    return new ChoiceTypeRestriction().fromJsonString(jsonString, options);
  }

  static equals(a: ChoiceTypeRestriction | PlainMessage<ChoiceTypeRestriction> | undefined, b: ChoiceTypeRestriction | PlainMessage<ChoiceTypeRestriction> | undefined): boolean {
    return proto3.util.equals(ChoiceTypeRestriction, a, b);
  }
}

/**
 * Structure used to create constraints as described in
 * https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.constraint
 *
 * @generated from message google.fhir.proto.FhirPathConstraint
 */
export class FhirPathConstraint extends Message<FhirPathConstraint> {
  /**
   * @generated from field: google.fhir.proto.FhirPathConstraint.Severity severity = 1;
   */
  severity = FhirPathConstraint_Severity.DEFAULT;

  /**
   * Human-readable description of the constraint
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The FHIRPath expression defining the constraint
   *
   * @generated from field: string expression = 3;
   */
  expression = "";

  constructor(data?: PartialMessage<FhirPathConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.FhirPathConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "severity", kind: "enum", T: proto3.getEnumType(FhirPathConstraint_Severity) },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FhirPathConstraint {
    return new FhirPathConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FhirPathConstraint {
    return new FhirPathConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FhirPathConstraint {
    return new FhirPathConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: FhirPathConstraint | PlainMessage<FhirPathConstraint> | undefined, b: FhirPathConstraint | PlainMessage<FhirPathConstraint> | undefined): boolean {
    return proto3.util.equals(FhirPathConstraint, a, b);
  }
}

/**
 * Constraint severity.
 *
 * @generated from enum google.fhir.proto.FhirPathConstraint.Severity
 */
export enum FhirPathConstraint_Severity {
  /**
   * Generator defaults to error if unset
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * @generated from enum value: ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: WARNING = 2;
   */
  WARNING = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FhirPathConstraint_Severity)
proto3.util.setEnumType(FhirPathConstraint_Severity, "google.fhir.proto.FhirPathConstraint.Severity", [
  { no: 0, name: "DEFAULT" },
  { no: 1, name: "ERROR" },
  { no: 2, name: "WARNING" },
]);

/**
 * Declares an extension to add to a profile. Modeled as a slice because
 * extensions are always sliced by URL, per the FHIR spec.
 *
 * @generated from message google.fhir.proto.ExtensionSlice
 */
export class ExtensionSlice extends Message<ExtensionSlice> {
  /**
   * Id in the Structure Definition of the field to add the extension to.
   * e.g., Patient.birthDate
   * Optional - if empty, defaults to top-level element.
   *
   * @generated from field: string field_id = 1;
   */
  fieldId = "";

  /**
   * @generated from field: google.fhir.proto.ElementData element_data = 2;
   */
  elementData?: ElementData;

  /**
   * Must be an absolute url for the Structure Definition that defines this
   * extension.
   * e.g., http://hl7.org/fhir/StructureDefinition/patient-birthTime
   * or https://g.co/fhir/extensions/BinaryClassificationMetadata
   *
   * @generated from field: string url = 3;
   */
  url = "";

  /**
   * Whether to set the "mustSupport" bit on the resulting ElementDefinition.
   * See:
   * http://hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.mustSupport
   *
   * @generated from field: bool must_support = 4;
   */
  mustSupport = false;

  constructor(data?: PartialMessage<ExtensionSlice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ExtensionSlice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "element_data", kind: "message", T: ElementData },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "must_support", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensionSlice {
    return new ExtensionSlice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensionSlice {
    return new ExtensionSlice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensionSlice {
    return new ExtensionSlice().fromJsonString(jsonString, options);
  }

  static equals(a: ExtensionSlice | PlainMessage<ExtensionSlice> | undefined, b: ExtensionSlice | PlainMessage<ExtensionSlice> | undefined): boolean {
    return proto3.util.equals(ExtensionSlice, a, b);
  }
}

/**
 * Defines a FHIR slice on a codeable concept as described in
 * https://www.hl7.org/fhir/profiling.html#slicing
 * These are used in the protobuf representation of profiled resources
 * to create concrete fields for specific code systems.
 *
 * @generated from message google.fhir.proto.CodeableConceptSlice
 */
export class CodeableConceptSlice extends Message<CodeableConceptSlice> {
  /**
   * Id in the Structure Definition of the CodeableConcept to slice.
   * e.g., Observation.code, or RiskAssessment.prediction.qualitativeRisk
   * Note that this should be of type CodeableConcept, NOT type Coding.
   *
   * @generated from field: string field_id = 1;
   */
  fieldId = "";

  /**
   * @generated from field: repeated google.fhir.proto.CodeableConceptSlice.CodingSlice coding_slice = 2;
   */
  codingSlice: CodeableConceptSlice_CodingSlice[] = [];

  /**
   * Whether or not to allow Codings that do not fit into any of the above
   * slices.
   * Optional - defaults to OPEN
   *
   * @generated from field: google.fhir.r4.core.SlicingRulesCode.Value rules = 4;
   */
  rules = SlicingRulesCode_Value.INVALID_UNINITIALIZED;

  constructor(data?: PartialMessage<CodeableConceptSlice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.CodeableConceptSlice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coding_slice", kind: "message", T: CodeableConceptSlice_CodingSlice, repeated: true },
    { no: 4, name: "rules", kind: "enum", T: proto3.getEnumType(SlicingRulesCode_Value) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeableConceptSlice {
    return new CodeableConceptSlice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeableConceptSlice {
    return new CodeableConceptSlice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeableConceptSlice {
    return new CodeableConceptSlice().fromJsonString(jsonString, options);
  }

  static equals(a: CodeableConceptSlice | PlainMessage<CodeableConceptSlice> | undefined, b: CodeableConceptSlice | PlainMessage<CodeableConceptSlice> | undefined): boolean {
    return proto3.util.equals(CodeableConceptSlice, a, b);
  }
}

/**
 * @generated from message google.fhir.proto.CodeableConceptSlice.CodingSlice
 */
export class CodeableConceptSlice_CodingSlice extends Message<CodeableConceptSlice_CodingSlice> {
  /**
   * @generated from field: google.fhir.proto.ElementData element_data = 1;
   */
  elementData?: ElementData;

  /**
   * @generated from field: google.fhir.proto.ValueSetBinding code_data = 2;
   */
  codeData?: ValueSetBinding;

  constructor(data?: PartialMessage<CodeableConceptSlice_CodingSlice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.CodeableConceptSlice.CodingSlice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_data", kind: "message", T: ElementData },
    { no: 2, name: "code_data", kind: "message", T: ValueSetBinding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeableConceptSlice_CodingSlice {
    return new CodeableConceptSlice_CodingSlice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeableConceptSlice_CodingSlice {
    return new CodeableConceptSlice_CodingSlice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeableConceptSlice_CodingSlice {
    return new CodeableConceptSlice_CodingSlice().fromJsonString(jsonString, options);
  }

  static equals(a: CodeableConceptSlice_CodingSlice | PlainMessage<CodeableConceptSlice_CodingSlice> | undefined, b: CodeableConceptSlice_CodingSlice | PlainMessage<CodeableConceptSlice_CodingSlice> | undefined): boolean {
    return proto3.util.equals(CodeableConceptSlice_CodingSlice, a, b);
  }
}

/**
 * Definition for a complex extension, i.e. one that contains one or more nested
 * simple or complex extension fields.
 *
 * @generated from message google.fhir.proto.ComplexExtension
 */
export class ComplexExtension extends Message<ComplexExtension> {
  /**
   * @generated from field: google.fhir.proto.ElementData element_data = 1;
   */
  elementData?: ElementData;

  /**
   * @generated from field: bool can_have_additional_extensions = 2;
   */
  canHaveAdditionalExtensions = false;

  /**
   * @generated from field: repeated google.fhir.proto.SimpleExtension simple_field = 3;
   */
  simpleField: SimpleExtension[] = [];

  /**
   * @generated from field: repeated google.fhir.proto.ComplexExtension complex_field = 4;
   */
  complexField: ComplexExtension[] = [];

  constructor(data?: PartialMessage<ComplexExtension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ComplexExtension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_data", kind: "message", T: ElementData },
    { no: 2, name: "can_have_additional_extensions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "simple_field", kind: "message", T: SimpleExtension, repeated: true },
    { no: 4, name: "complex_field", kind: "message", T: ComplexExtension, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComplexExtension {
    return new ComplexExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComplexExtension {
    return new ComplexExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComplexExtension {
    return new ComplexExtension().fromJsonString(jsonString, options);
  }

  static equals(a: ComplexExtension | PlainMessage<ComplexExtension> | undefined, b: ComplexExtension | PlainMessage<ComplexExtension> | undefined): boolean {
    return proto3.util.equals(ComplexExtension, a, b);
  }
}

/**
 * Definition for a simple extension, i.e. one that contains
 * only a primitive data type.
 * TODO(b/244184211): support references with target profiles.
 *
 * @generated from message google.fhir.proto.SimpleExtension
 */
export class SimpleExtension extends Message<SimpleExtension> {
  /**
   * @generated from field: google.fhir.proto.ElementData element_data = 1;
   */
  elementData?: ElementData;

  /**
   * Must be one of the types listed in the Extension.value[x] element here:
   * http://hl7.org/fhir/extension.profile.json
   * If this field has size > 1 it will generate a choice-type value
   * For legacy reasons, if this is unset but `code_type` is set, this is
   * assumed to be of type `code`.
   *
   * @generated from field: repeated string type = 2;
   */
  type: string[] = [];

  /**
   * For fields of type code, Coding, or CodeableConcept, binding to a ValueSet.
   * See: https://www.hl7.org/fhir/terminologies.html
   *
   * @generated from field: google.fhir.proto.ValueSetBinding code_type = 3;
   */
  codeType?: ValueSetBinding;

  /**
   * @generated from field: bool can_have_extensions = 4;
   */
  canHaveExtensions = false;

  constructor(data?: PartialMessage<SimpleExtension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.SimpleExtension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_data", kind: "message", T: ElementData },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "code_type", kind: "message", T: ValueSetBinding },
    { no: 4, name: "can_have_extensions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleExtension {
    return new SimpleExtension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleExtension {
    return new SimpleExtension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleExtension {
    return new SimpleExtension().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleExtension | PlainMessage<SimpleExtension> | undefined, b: SimpleExtension | PlainMessage<SimpleExtension> | undefined): boolean {
    return proto3.util.equals(SimpleExtension, a, b);
  }
}

/**
 * Description of a data element being profiled.
 *
 * @generated from message google.fhir.proto.ElementData
 */
export class ElementData extends Message<ElementData> {
  /**
   * Name for the element.
   * For top-level elements:
   * * This will be the name of the generated message
   * * Must TitleCased and unique within all top-level elements in the package.
   * * The url will be this name appended to Extensions#base_url.
   * For subfields:
   * * This will be the name of the field
   * * Must jsonCased and unique within the containing message.
   * * If this represents a container field, the generated message will be
   *   this name in TitleCase.
   * * The url will be equal to the name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Size constraints for the element.
   *
   * @generated from field: google.fhir.proto.SizeRestriction size_restriction = 2;
   */
  sizeRestriction = SizeRestriction.UNSET;

  /**
   * Human-readable description ofthe element.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Short description.
   * Optional - will re-use description if absent
   *
   * @generated from field: string short = 4;
   */
  short = "";

  /**
   * Free-form comment
   * Optional
   *
   * @generated from field: string comment = 5;
   */
  comment = "";

  /**
   * If set, provides an override for the structure definition URL.
   * Should ONLY be used on top-level elements.
   *
   * @generated from field: string url_override = 6;
   */
  urlOverride = "";

  constructor(data?: PartialMessage<ElementData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ElementData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_restriction", kind: "enum", T: proto3.getEnumType(SizeRestriction) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "short", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "url_override", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ElementData {
    return new ElementData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ElementData {
    return new ElementData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ElementData {
    return new ElementData().fromJsonString(jsonString, options);
  }

  static equals(a: ElementData | PlainMessage<ElementData> | undefined, b: ElementData | PlainMessage<ElementData> | undefined): boolean {
    return proto3.util.equals(ElementData, a, b);
  }
}

/**
 * Describes ValueSet bindings for terminology fields.
 *
 * @generated from message google.fhir.proto.ValueSetBinding
 */
export class ValueSetBinding extends Message<ValueSetBinding> {
  /**
   * Fixed ValueSet Url
   *
   * @generated from field: string system = 1;
   */
  system = "";

  /**
   * "Strength" of value set binding - i.e., whether to allow codes that
   * are not in that value set.
   * Optional - defaults to required.
   *
   * @generated from field: google.fhir.r4.core.BindingStrengthCode.Value binding_strength = 2;
   */
  bindingStrength = BindingStrengthCode_Value.INVALID_UNINITIALIZED;

  /**
   * Optional - if set, this code will have a fixed value, and will not be
   * inlined as a field.
   *
   * @generated from field: string fixed_value = 3;
   */
  fixedValue = "";

  /**
   * Optional human-readable description of the binding.
   * See:
   * https://www.hl7.org/fhir/elementdefinition-definitions.html#ElementDefinition.binding.description
   *
   * @generated from field: string description = 4;
   */
  description = "";

  constructor(data?: PartialMessage<ValueSetBinding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ValueSetBinding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "system", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "binding_strength", kind: "enum", T: proto3.getEnumType(BindingStrengthCode_Value) },
    { no: 3, name: "fixed_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueSetBinding {
    return new ValueSetBinding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueSetBinding {
    return new ValueSetBinding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueSetBinding {
    return new ValueSetBinding().fromJsonString(jsonString, options);
  }

  static equals(a: ValueSetBinding | PlainMessage<ValueSetBinding> | undefined, b: ValueSetBinding | PlainMessage<ValueSetBinding> | undefined): boolean {
    return proto3.util.equals(ValueSetBinding, a, b);
  }
}

/**
 * A compact representation of a code system used by the
 * TerminologyGenerator to build the FHIR equivalent.
 * See https://www.hl7.org/fhir/codesystem.html for
 * the FHIR resource this will generate.
 *
 * @generated from message google.fhir.proto.CodeSystemConfig
 */
export class CodeSystemConfig extends Message<CodeSystemConfig> {
  /**
   * Sets the FHIR CodeSystem.name field.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Sets the FHIR CodeSystem.status field.
   *
   * @generated from field: google.fhir.r4.core.PublicationStatusCode.Value status = 2;
   */
  status = PublicationStatusCode_Value.INVALID_UNINITIALIZED;

  /**
   * Sets the FHIR CodeSystem.description field.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Overrides the URL for the generated code system. The generator
   * will use the PackageInfo.baseUrl/ValuesetConfig.name if this is unset.
   *
   * @generated from field: string url_override = 4;
   */
  urlOverride = "";

  /**
   * @generated from field: repeated google.fhir.proto.CodeSystemConfig.Concept concept = 5;
   */
  concept: CodeSystemConfig_Concept[] = [];

  constructor(data?: PartialMessage<CodeSystemConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.CodeSystemConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(PublicationStatusCode_Value) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "url_override", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "concept", kind: "message", T: CodeSystemConfig_Concept, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeSystemConfig {
    return new CodeSystemConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeSystemConfig {
    return new CodeSystemConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeSystemConfig {
    return new CodeSystemConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CodeSystemConfig | PlainMessage<CodeSystemConfig> | undefined, b: CodeSystemConfig | PlainMessage<CodeSystemConfig> | undefined): boolean {
    return proto3.util.equals(CodeSystemConfig, a, b);
  }
}

/**
 * Defines the CodeSystem.concept structure to be generated.
 *
 * @generated from message google.fhir.proto.CodeSystemConfig.Concept
 */
export class CodeSystemConfig_Concept extends Message<CodeSystemConfig_Concept> {
  /**
   * Sets the FHIR Codesystem.concept.code field.
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * Sets the FHIR Codesystem.concept.display field.
   *
   * @generated from field: string display = 2;
   */
  display = "";

  /**
   * Sets the FHIR Codesystem.concept.definition field.
   *
   * @generated from field: string definition = 3;
   */
  definition = "";

  /**
   * Flag indicating the code value is deprecated.
   *
   * @generated from field: bool deprecated = 4;
   */
  deprecated = false;

  constructor(data?: PartialMessage<CodeSystemConfig_Concept>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.CodeSystemConfig.Concept";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "definition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeSystemConfig_Concept {
    return new CodeSystemConfig_Concept().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeSystemConfig_Concept {
    return new CodeSystemConfig_Concept().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeSystemConfig_Concept {
    return new CodeSystemConfig_Concept().fromJsonString(jsonString, options);
  }

  static equals(a: CodeSystemConfig_Concept | PlainMessage<CodeSystemConfig_Concept> | undefined, b: CodeSystemConfig_Concept | PlainMessage<CodeSystemConfig_Concept> | undefined): boolean {
    return proto3.util.equals(CodeSystemConfig_Concept, a, b);
  }
}

/**
 * A compact representation of a value set used by the
 * TerminologyGenerator to build the FHIR equivalent.
 * See https://www.hl7.org/fhir/valueset.html for the FHIR
 * resource this will generate.
 *
 * @generated from message google.fhir.proto.ValueSetConfig
 */
export class ValueSetConfig extends Message<ValueSetConfig> {
  /**
   * Sets the FHIR ValueSet.name field.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Sets the FHIR ValueSet.status field with the publication status.
   *
   * @generated from field: google.fhir.r4.core.PublicationStatusCode.Value status = 2;
   */
  status = PublicationStatusCode_Value.INVALID_UNINITIALIZED;

  /**
   * Sets the FHIR ValueSet.description field.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Overrides the URL for the generated valueset. The generator
   * will use the PackageInfo.baseUrl/ValuesetConfig.name if this is unset.
   *
   * @generated from field: string url_override = 4;
   */
  urlOverride = "";

  /**
   * @generated from field: repeated google.fhir.proto.ValueSetConfig.System system = 5;
   */
  system: ValueSetConfig_System[] = [];

  constructor(data?: PartialMessage<ValueSetConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ValueSetConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(PublicationStatusCode_Value) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "url_override", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "system", kind: "message", T: ValueSetConfig_System, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueSetConfig {
    return new ValueSetConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueSetConfig {
    return new ValueSetConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueSetConfig {
    return new ValueSetConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ValueSetConfig | PlainMessage<ValueSetConfig> | undefined, b: ValueSetConfig | PlainMessage<ValueSetConfig> | undefined): boolean {
    return proto3.util.equals(ValueSetConfig, a, b);
  }
}

/**
 * A code system and the subset of its values to include in the value set.
 *
 * @generated from message google.fhir.proto.ValueSetConfig.System
 */
export class ValueSetConfig_System extends Message<ValueSetConfig_System> {
  /**
   * The code system URL.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * Codes from this system to include.
   *
   * @generated from field: repeated string include = 2;
   */
  include: string[] = [];

  /**
   * Codes from this system to exclude.
   *
   * @generated from field: repeated string exclude = 3;
   */
  exclude: string[] = [];

  constructor(data?: PartialMessage<ValueSetConfig_System>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.fhir.proto.ValueSetConfig.System";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "include", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "exclude", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueSetConfig_System {
    return new ValueSetConfig_System().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueSetConfig_System {
    return new ValueSetConfig_System().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueSetConfig_System {
    return new ValueSetConfig_System().fromJsonString(jsonString, options);
  }

  static equals(a: ValueSetConfig_System | PlainMessage<ValueSetConfig_System> | undefined, b: ValueSetConfig_System | PlainMessage<ValueSetConfig_System> | undefined): boolean {
    return proto3.util.equals(ValueSetConfig_System, a, b);
  }
}

